<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>softusbduino: SoftUsb/usbdrv.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">softusbduino</div>
  </td>
  <td>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">SoftUsb/usbdrv.c</div>  </div>
</div>
<div class="contents">
<a href="usbdrv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Name: usbdrv.c</span>
<a name="l00002"></a>00002 <span class="comment"> * Project: V-USB, virtual USB port for Atmel&#39;s(r) AVR(r) microcontrollers</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Christian Starkjohann</span>
<a name="l00004"></a>00004 <span class="comment"> * Creation Date: 2004-12-29</span>
<a name="l00005"></a>00005 <span class="comment"> * Tabsize: 4</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH</span>
<a name="l00007"></a>00007 <span class="comment"> * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)</span>
<a name="l00008"></a>00008 <span class="comment"> * This Revision: $Id: usbdrv.c 791 2010-07-15 15:56:13Z cs $</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="usbportability_8h.html">usbportability.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="usbdrv_8h.html">usbdrv.h</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="oddebug_8h.html">oddebug.h</a>&quot;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="comment">/*</span>
<a name="l00016"></a>00016 <span class="comment">General Description:</span>
<a name="l00017"></a>00017 <span class="comment">This module implements the C-part of the USB driver. See usbdrv.h for a</span>
<a name="l00018"></a>00018 <span class="comment">documentation of the entire driver.</span>
<a name="l00019"></a>00019 <span class="comment">*/</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* raw USB registers / interface to assembler code: */</span>
<a name="l00024"></a><a class="code" href="usbdrv_8c.html#a50d7f851abf281804143e797d0bfbf04">00024</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_8c.html#a50d7f851abf281804143e797d0bfbf04">usbRxBuf</a>[2*<a class="code" href="usbdrv_8h.html#a1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];  <span class="comment">/* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */</span>
<a name="l00025"></a><a class="code" href="usbdrv_8c.html#a6b0f7b83997deee705eb56462e3f1fce">00025</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#a6b0f7b83997deee705eb56462e3f1fce">usbInputBufOffset</a>;  <span class="comment">/* offset in usbRxBuf used for low level receiving */</span>
<a name="l00026"></a><a class="code" href="usbdrv_8c.html#a3f91a04b325ad5232d270839891e5856">00026</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#a3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a>;      <span class="comment">/* assigned during enumeration, defaults to 0 */</span>
<a name="l00027"></a><a class="code" href="usbdrv_8c.html#ab9c08d1850db1e4d9feea687bc129425">00027</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#ab9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a>;   <span class="comment">/* device ID which should be set after status phase */</span>
<a name="l00028"></a><a class="code" href="usbdrv_8h.html#aa43502fd98afab29fcd5115c1f2c4067">00028</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#aa43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;   <span class="comment">/* currently selected configuration. Administered by driver, but not used */</span>
<a name="l00029"></a><a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">00029</a> <span class="keyword">volatile</span> <a class="code" href="usbdrv_8h.html#af2cbb84f982ea77dfbb738af3a027591">schar</a> <a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">usbRxLen</a>;        <span class="comment">/* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow control */</span>
<a name="l00030"></a><a class="code" href="usbdrv_8c.html#ae302a61abfeb0784f42a903dd44aad1e">00030</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#ae302a61abfeb0784f42a903dd44aad1e">usbCurrentTok</a>;      <span class="comment">/* last token received or endpoint number for last OUT token if != 0 */</span>
<a name="l00031"></a><a class="code" href="usbdrv_8h.html#ae2a9422baba7da8914129e0784ab2c05">00031</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#ae2a9422baba7da8914129e0784ab2c05">usbRxToken</a>;         <span class="comment">/* token for data we received; or endpont number for last OUT */</span>
<a name="l00032"></a><a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">00032</a> <span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> <a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;   <span class="comment">/* number of bytes to transmit with next IN token or handshake token */</span>
<a name="l00033"></a><a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">00033</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       <a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[<a class="code" href="usbdrv_8h.html#a1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a>];<span class="comment">/* data to transmit with next IN, free if usbTxLen contains handshake token */</span>
<a name="l00034"></a>00034 <span class="preprocessor">#if USB_COUNT_SOF</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="keyword">volatile</span> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>  usbSofCount;    <span class="comment">/* incremented by assembler module every SOF */</span>
<a name="l00036"></a>00036 <span class="preprocessor">#endif</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; !USB_CFG_SUPPRESS_INTR_CODE</span>
<a name="l00038"></a><a class="code" href="usbdrv_8h.html#a8787d5ad73afd0d305818dfbdce2bc85">00038</a> <span class="preprocessor"></span><a class="code" href="structusbTxStatus.html">usbTxStatus_t</a>  <a class="code" href="usbdrv_8c.html#a8787d5ad73afd0d305818dfbdce2bc85">usbTxStatus1</a>;
<a name="l00039"></a>00039 <span class="preprocessor">#   if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><a class="code" href="structusbTxStatus.html">usbTxStatus_t</a>  <a class="code" href="usbdrv_8h.html#a59db875c71a09a29e967500bdbfce4e0">usbTxStatus3</a>;
<a name="l00041"></a>00041 <span class="preprocessor">#   endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_CHECK_DATA_TOGGLING</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       usbCurrentDataToken;<span class="comment">/* when we check data toggling to ignore duplicate packets */</span>
<a name="l00045"></a>00045 <span class="preprocessor">#endif</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00047"></a>00047 <span class="comment">/* USB status registers / not shared with asm code */</span>
<a name="l00048"></a><a class="code" href="usbdrv_8h.html#a5f78c8584830588b8c0c8f2a27772f8e">00048</a> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>               *<a class="code" href="usbdrv_8c.html#a5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;     <span class="comment">/* data to transmit next -- ROM or RAM address */</span>
<a name="l00049"></a>00049 <span class="keyword">static</span> <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a>  usbMsgLen = <a class="code" href="usbdrv_8h.html#a0bf378ff9540265128eef4f085176dcc">USB_NO_MSG</a>; <span class="comment">/* remaining number of bytes */</span>
<a name="l00050"></a>00050 <span class="keyword">static</span> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>        usbMsgFlags;    <span class="comment">/* flag values see below */</span>
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="usbdrv_8c.html#a06db19dbad17d54fc6f3742ab0afba69">00052</a> <span class="preprocessor">#define USB_FLG_MSGPTR_IS_ROM   (1&lt;&lt;6)</span>
<a name="l00053"></a><a class="code" href="usbdrv_8c.html#ad2fe7ee90d3349e1399f61eda81d48e9">00053</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_FLG_USE_USER_RW     (1&lt;&lt;7)</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>
<a name="l00055"></a>00055 <span class="comment">/*</span>
<a name="l00056"></a>00056 <span class="comment">optimizing hints:</span>
<a name="l00057"></a>00057 <span class="comment">- do not post/pre inc/dec integer values in operations</span>
<a name="l00058"></a>00058 <span class="comment">- assign value of USB_READ_FLASH() to register variables and don&#39;t use side effects in arg</span>
<a name="l00059"></a>00059 <span class="comment">- use narrow scope for variables which should be in X/Y/Z register</span>
<a name="l00060"></a>00060 <span class="comment">- assign char sized expressions to variables to force 8 bit arithmetics</span>
<a name="l00061"></a>00061 <span class="comment">*/</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/* -------------------------- String Descriptors --------------------------- */</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRINGS == 0</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_0 == 0</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_0</span>
<a name="l00069"></a><a class="code" href="usbdrv_8c.html#a9c0556a4c6c5a1ab8f6598aee8e5bf6a">00069</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)</span>
<a name="l00070"></a><a class="code" href="usbdrv_8h.html#ac16de84418d64a0e74a4e551fc9ac786">00070</a> <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#ac16de84418d64a0e74a4e551fc9ac786">usbDescriptorString0</a>[] = { <span class="comment">/* language descriptor */</span>
<a name="l00071"></a>00071     4,          <span class="comment">/* sizeof(usbDescriptorString0): length of descriptor in bytes */</span>
<a name="l00072"></a>00072     3,          <span class="comment">/* descriptor type */</span>
<a name="l00073"></a>00073     0x09, 0x04, <span class="comment">/* language index (0x0409 = US-English) */</span>
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 <span class="preprocessor">#endif</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 &amp;&amp; USB_CFG_VENDOR_NAME_LEN</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_VENDOR</span>
<a name="l00079"></a><a class="code" href="usbdrv_8c.html#a55edf2117128387162339d98ba2af0f4">00079</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)</span>
<a name="l00080"></a><a class="code" href="usbdrv_8h.html#a9974e0350b3ad7adafc3b1f0a47278ca">00080</a> <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">int</span>  <a class="code" href="usbdrv_8c.html#a9974e0350b3ad7adafc3b1f0a47278ca">usbDescriptorStringVendor</a>[] = {
<a name="l00081"></a>00081     <a class="code" href="usbdrv_8h.html#ad94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="usbconfig_8h.html#a3085d820d9dc6e939737a3f1b9a457d7">USB_CFG_VENDOR_NAME_LEN</a>),
<a name="l00082"></a>00082     <a class="code" href="usbconfig_8h.html#a25a2baf5c8feb0982a47050423add0ec">USB_CFG_VENDOR_NAME</a>
<a name="l00083"></a>00083 };
<a name="l00084"></a>00084 <span class="preprocessor">#endif</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 &amp;&amp; USB_CFG_DEVICE_NAME_LEN</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_PRODUCT</span>
<a name="l00088"></a><a class="code" href="usbdrv_8c.html#aa08084f9755a643e02d469b66b129ef6">00088</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)</span>
<a name="l00089"></a><a class="code" href="usbdrv_8h.html#a030c4d21be999d0deafccc65499a44df">00089</a> <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">int</span>  <a class="code" href="usbdrv_8c.html#a030c4d21be999d0deafccc65499a44df">usbDescriptorStringDevice</a>[] = {
<a name="l00090"></a>00090     <a class="code" href="usbdrv_8h.html#ad94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(<a class="code" href="usbconfig_8h.html#ae68f17e6baf13805abc56e74beadeb57">USB_CFG_DEVICE_NAME_LEN</a>),
<a name="l00091"></a>00091     <a class="code" href="usbconfig_8h.html#a9b482a2b2740652ffe7dcb6695ca0c91">USB_CFG_DEVICE_NAME</a>
<a name="l00092"></a>00092 };
<a name="l00093"></a>00093 <span class="preprocessor">#endif</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 &amp;&amp; USB_CFG_SERIAL_NUMBER_LEN</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">int</span> <a class="code" href="usbdrv_8h.html#a04e6662c39d818a0c4ae16db46276194">usbDescriptorStringSerialNumber</a>[] = {
<a name="l00099"></a>00099     <a class="code" href="usbdrv_8h.html#ad94ebd3045d80d1e2ab32c22be4ff96e">USB_STRING_DESCRIPTOR_HEADER</a>(USB_CFG_SERIAL_NUMBER_LEN),
<a name="l00100"></a>00100     USB_CFG_SERIAL_NUMBER
<a name="l00101"></a>00101 };
<a name="l00102"></a>00102 <span class="preprocessor">#endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span>
<a name="l00104"></a>00104 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS == 0 */</span>
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">/* --------------------------- Device Descriptor --------------------------- */</span>
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_DEVICE == 0</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_DEVICE</span>
<a name="l00110"></a><a class="code" href="usbdrv_8c.html#aa916bf33f6f8f481a219d0a81b5b225e">00110</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)</span>
<a name="l00111"></a><a class="code" href="usbdrv_8h.html#a4832dd2433bcc12b444a31dc4a8bfc49">00111</a> <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#a4832dd2433bcc12b444a31dc4a8bfc49">usbDescriptorDevice</a>[] = {    <span class="comment">/* USB device descriptor */</span>
<a name="l00112"></a>00112     18,         <span class="comment">/* sizeof(usbDescriptorDevice): length of descriptor in bytes */</span>
<a name="l00113"></a>00113     <a class="code" href="usbdrv_8h.html#a5b76593f7b6295a4a599aba4476ec258">USBDESCR_DEVICE</a>,        <span class="comment">/* descriptor type */</span>
<a name="l00114"></a>00114     0x10, 0x01,             <span class="comment">/* USB version supported */</span>
<a name="l00115"></a>00115     <a class="code" href="usbconfig_8h.html#a9ce4f96ad98b3db8205691e8bc723e55">USB_CFG_DEVICE_CLASS</a>,
<a name="l00116"></a>00116     <a class="code" href="usbconfig_8h.html#a89e5ad66f8b835866e7d836c73bfd30d">USB_CFG_DEVICE_SUBCLASS</a>,
<a name="l00117"></a>00117     0,                      <span class="comment">/* protocol */</span>
<a name="l00118"></a>00118     8,                      <span class="comment">/* max packet size */</span>
<a name="l00119"></a>00119     <span class="comment">/* the following two casts affect the first byte of the constant only, but</span>
<a name="l00120"></a>00120 <span class="comment">     * that&#39;s sufficient to avoid a warning with the default values.</span>
<a name="l00121"></a>00121 <span class="comment">     */</span>
<a name="l00122"></a>00122     (char)<a class="code" href="usbconfig_8h.html#a9326b8ec9f809ce66d54349691646930">USB_CFG_VENDOR_ID</a>,<span class="comment">/* 2 bytes */</span>
<a name="l00123"></a>00123     (<span class="keywordtype">char</span>)<a class="code" href="usbconfig_8h.html#abc740455309399430b0f49bf7931d1d7">USB_CFG_DEVICE_ID</a>,<span class="comment">/* 2 bytes */</span>
<a name="l00124"></a>00124     <a class="code" href="usbconfig_8h.html#aba3c7c0cd4055ba3bbf5df38e57b6d27">USB_CFG_DEVICE_VERSION</a>, <span class="comment">/* 2 bytes */</span>
<a name="l00125"></a>00125     <a class="code" href="usbdrv_8c.html#a55edf2117128387162339d98ba2af0f4">USB_CFG_DESCR_PROPS_STRING_VENDOR</a> != 0 ? 1 : 0,         <span class="comment">/* manufacturer string index */</span>
<a name="l00126"></a>00126     <a class="code" href="usbdrv_8c.html#aa08084f9755a643e02d469b66b129ef6">USB_CFG_DESCR_PROPS_STRING_PRODUCT</a> != 0 ? 2 : 0,        <span class="comment">/* product string index */</span>
<a name="l00127"></a>00127     <a class="code" href="usbconfig_8h.html#a82224c07d3a1f9fcccbff70b71c8ea51">USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</a> != 0 ? 3 : 0,  <span class="comment">/* serial number string index */</span>
<a name="l00128"></a>00128     1,          <span class="comment">/* number of configurations */</span>
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 <span class="preprocessor">#endif</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00132"></a>00132 <span class="comment">/* ----------------------- Configuration Descriptor ------------------------ */</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_HID_REPORT != 0 &amp;&amp; USB_CFG_DESCR_PROPS_HID == 0</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_HID</span>
<a name="l00136"></a><a class="code" href="usbdrv_8c.html#adfbd53b5310c36b1e4b06d6a3b992e8a">00136</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_HID     9   </span><span class="comment">/* length of HID descriptor in config descriptor below */</span>
<a name="l00137"></a>00137 <span class="preprocessor">#endif</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>
<a name="l00139"></a>00139 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_CONFIGURATION == 0</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#undef USB_CFG_DESCR_PROPS_CONFIGURATION</span>
<a name="l00141"></a><a class="code" href="usbdrv_8c.html#a8aae9f682ca9f91faae0453e4351a50b">00141</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)</span>
<a name="l00142"></a><a class="code" href="usbdrv_8h.html#a86288669b638000acf9548272f73e7f6">00142</a> <span class="preprocessor"></span><a class="code" href="SoftUsb_8h.html#af17f668395c2bba635e5737bcac88f4b">PROGMEM</a> <span class="keywordtype">char</span> <a class="code" href="usbdrv_8c.html#a86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a>[] = {    <span class="comment">/* USB configuration descriptor */</span>
<a name="l00143"></a>00143     9,          <span class="comment">/* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */</span>
<a name="l00144"></a>00144     <a class="code" href="usbdrv_8h.html#a6ff1081ad7212a0c7009ef5b79f3669f">USBDESCR_CONFIG</a>,    <span class="comment">/* descriptor type */</span>
<a name="l00145"></a>00145     18 + 7 * <a class="code" href="usbconfig_8h.html#afe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a> + 7 * <a class="code" href="usbconfig_8h.html#a973c0b60531876ba52c4447e0fd0a150">USB_CFG_HAVE_INTRIN_ENDPOINT3</a> +
<a name="l00146"></a>00146                 (<a class="code" href="usbdrv_8c.html#adfbd53b5310c36b1e4b06d6a3b992e8a">USB_CFG_DESCR_PROPS_HID</a> &amp; 0xff), 0,
<a name="l00147"></a>00147                 <span class="comment">/* total length of data returned (including inlined descriptors) */</span>
<a name="l00148"></a>00148     1,          <span class="comment">/* number of interfaces in this configuration */</span>
<a name="l00149"></a>00149     1,          <span class="comment">/* index of this configuration */</span>
<a name="l00150"></a>00150     0,          <span class="comment">/* configuration name string index */</span>
<a name="l00151"></a>00151 #<span class="keywordflow">if</span> <a class="code" href="usbconfig_8h.html#ad5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>
<a name="l00152"></a>00152     (1 &lt;&lt; 7) | <a class="code" href="usbdrv_8h.html#afa0dd9c06af4b033461ba3c755ca90bb">USBATTR_SELFPOWER</a>,       <span class="comment">/* attributes */</span>
<a name="l00153"></a>00153 <span class="preprocessor">#else</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span>    (1 &lt;&lt; 7),                           <span class="comment">/* attributes */</span>
<a name="l00155"></a>00155 #endif
<a name="l00156"></a>00156     <a class="code" href="usbconfig_8h.html#abe324d9b00dc186bcbac65ed0f94811c">USB_CFG_MAX_BUS_POWER</a>/2,            <span class="comment">/* max USB current in 2mA units */</span>
<a name="l00157"></a>00157 <span class="comment">/* interface descriptor follows inline: */</span>
<a name="l00158"></a>00158     9,          <span class="comment">/* sizeof(usbDescrInterface): length of descriptor in bytes */</span>
<a name="l00159"></a>00159     <a class="code" href="usbdrv_8h.html#a1ce81e6fb124d8747018b4343faa65ba">USBDESCR_INTERFACE</a>, <span class="comment">/* descriptor type */</span>
<a name="l00160"></a>00160     0,          <span class="comment">/* index of this interface */</span>
<a name="l00161"></a>00161     0,          <span class="comment">/* alternate setting for this interface */</span>
<a name="l00162"></a>00162     <a class="code" href="usbconfig_8h.html#afe176bba6f05a034a5eec11f7ed6302b">USB_CFG_HAVE_INTRIN_ENDPOINT</a> + <a class="code" href="usbconfig_8h.html#a973c0b60531876ba52c4447e0fd0a150">USB_CFG_HAVE_INTRIN_ENDPOINT3</a>, <span class="comment">/* endpoints excl 0: number of endpoint descriptors to follow */</span>
<a name="l00163"></a>00163     <a class="code" href="usbconfig_8h.html#a34f6fe9486b66e8220a82a0eb87a7447">USB_CFG_INTERFACE_CLASS</a>,
<a name="l00164"></a>00164     <a class="code" href="usbconfig_8h.html#ac643f27afa43062c19b8f0674b6be1b5">USB_CFG_INTERFACE_SUBCLASS</a>,
<a name="l00165"></a>00165     <a class="code" href="usbconfig_8h.html#a8ddab89b764bfd88d024c7d9c9931de3">USB_CFG_INTERFACE_PROTOCOL</a>,
<a name="l00166"></a>00166     0,          <span class="comment">/* string index for interface */</span>
<a name="l00167"></a>00167 #<span class="keywordflow">if</span> (<a class="code" href="usbdrv_8c.html#adfbd53b5310c36b1e4b06d6a3b992e8a">USB_CFG_DESCR_PROPS_HID</a> &amp; 0xff)    <span class="comment">/* HID descriptor */</span>
<a name="l00168"></a>00168     9,          <span class="comment">/* sizeof(usbDescrHID): length of descriptor in bytes */</span>
<a name="l00169"></a>00169     <a class="code" href="usbdrv_8h.html#ade4fe1fba6aca94a379fdbacbbcc6800">USBDESCR_HID</a>,   <span class="comment">/* descriptor type: HID */</span>
<a name="l00170"></a>00170     0x01, 0x01, <span class="comment">/* BCD representation of HID version */</span>
<a name="l00171"></a>00171     0x00,       <span class="comment">/* target country code */</span>
<a name="l00172"></a>00172     0x01,       <span class="comment">/* number of HID Report (or other HID class) Descriptor infos to follow */</span>
<a name="l00173"></a>00173     0x22,       <span class="comment">/* descriptor type: report */</span>
<a name="l00174"></a>00174     <a class="code" href="usbconfig_8h.html#a47d9bef5c10a1b9ba917eca583d2abc9">USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH</a>, 0,  <span class="comment">/* total length of report descriptor */</span>
<a name="l00175"></a>00175 <span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT    </span><span class="comment">/* endpoint descriptor for endpoint 1 */</span>
<a name="l00177"></a>00177     7,          <span class="comment">/* sizeof(usbDescrEndpoint) */</span>
<a name="l00178"></a>00178     <a class="code" href="usbdrv_8h.html#ab2c475dbe374ed8bc514893fb97a6083">USBDESCR_ENDPOINT</a>,  <span class="comment">/* descriptor type = endpoint */</span>
<a name="l00179"></a>00179     (char)0x81, <span class="comment">/* IN endpoint number 1 */</span>
<a name="l00180"></a>00180     0x03,       <span class="comment">/* attrib: Interrupt endpoint */</span>
<a name="l00181"></a>00181     8, 0,       <span class="comment">/* maximum packet size */</span>
<a name="l00182"></a>00182     <a class="code" href="usbconfig_8h.html#a9cccddfefa62f926a0d7bba9f183a4d3">USB_CFG_INTR_POLL_INTERVAL</a>, <span class="comment">/* in ms */</span>
<a name="l00183"></a>00183 #endif
<a name="l00184"></a>00184 #<span class="keywordflow">if</span> <a class="code" href="usbconfig_8h.html#a973c0b60531876ba52c4447e0fd0a150">USB_CFG_HAVE_INTRIN_ENDPOINT3</a>   <span class="comment">/* endpoint descriptor for endpoint 3 */</span>
<a name="l00185"></a>00185     7,          <span class="comment">/* sizeof(usbDescrEndpoint) */</span>
<a name="l00186"></a>00186     USBDESCR_ENDPOINT,  <span class="comment">/* descriptor type = endpoint */</span>
<a name="l00187"></a>00187     (<span class="keywordtype">char</span>)(0x80 | <a class="code" href="usbconfig_8h.html#a6ba1def233ee0e102febe80e53af53a7">USB_CFG_EP3_NUMBER</a>), <span class="comment">/* IN endpoint number 3 */</span>
<a name="l00188"></a>00188     0x03,       <span class="comment">/* attrib: Interrupt endpoint */</span>
<a name="l00189"></a>00189     8, 0,       <span class="comment">/* maximum packet size */</span>
<a name="l00190"></a>00190     <a class="code" href="usbconfig_8h.html#a9cccddfefa62f926a0d7bba9f183a4d3">USB_CFG_INTR_POLL_INTERVAL</a>, <span class="comment">/* in ms */</span>
<a name="l00191"></a>00191 #endif
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 <span class="preprocessor">#endif</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00195"></a>00195 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>  usbResetDataToggling(<span class="keywordtype">void</span>)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; !USB_CFG_SUPPRESS_INTR_CODE</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#aca823e3f6e7e9b50d59f00a1099fdcf5">USB_SET_DATATOKEN1</a>(<a class="code" href="usbdrv_8h.html#a0890d166b64c89804154892c992bb8a9">USB_INITIAL_DATATOKEN</a>);  <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00201"></a>00201 <span class="preprocessor">#   if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#a88a3c0e0377c62f13d123a536a112adf">USB_SET_DATATOKEN3</a>(<a class="code" href="usbdrv_8h.html#a0890d166b64c89804154892c992bb8a9">USB_INITIAL_DATATOKEN</a>);  <span class="comment">/* reset data toggling for interrupt endpoint */</span>
<a name="l00203"></a>00203 <span class="preprocessor">#   endif</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>}
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>  usbResetStall(<span class="keywordtype">void</span>)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT &amp;&amp; USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span>        <a class="code" href="usbdrv_8h.html#aac21ed24e5889d02bdecaefb2881dca9">usbTxLen1</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00211"></a>00211 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>        <a class="code" href="usbdrv_8h.html#aca93482629ab3ddcbceedd43f1dd976c">usbTxLen3</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00213"></a>00213 <span class="preprocessor">#endif</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>}
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="preprocessor">#if !USB_CFG_SUPPRESS_INTR_CODE</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> usbGenericSetInterrupt(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> len, <a class="code" href="structusbTxStatus.html">usbTxStatus_t</a> *txStatus)
<a name="l00222"></a>00222 {
<a name="l00223"></a>00223 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>   *p;
<a name="l00224"></a>00224 <span class="keywordtype">char</span>    i;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8h.html#aac21ed24e5889d02bdecaefb2881dca9">usbTxLen1</a> == <a class="code" href="usbdrv_8h.html#a1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>)
<a name="l00228"></a>00228         <span class="keywordflow">return</span>;
<a name="l00229"></a>00229 <span class="preprocessor">#endif</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(txStatus-&gt;<a class="code" href="structusbTxStatus.html#a3ee6d00644cd8bb758bffffed53022b6">len</a> &amp; 0x10){   <span class="comment">/* packet buffer was empty */</span>
<a name="l00231"></a>00231         txStatus-&gt;<a class="code" href="structusbTxStatus.html#ac0cd1cbb98d720cd1f6b458e5dca8b74">buffer</a>[0] ^= <a class="code" href="usbdrv_8h.html#addf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a> ^ <a class="code" href="usbdrv_8h.html#a62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>; <span class="comment">/* toggle token */</span>
<a name="l00232"></a>00232     }<span class="keywordflow">else</span>{
<a name="l00233"></a>00233         txStatus-&gt;<a class="code" href="structusbTxStatus.html#a3ee6d00644cd8bb758bffffed53022b6">len</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>; <span class="comment">/* avoid sending outdated (overwritten) interrupt data */</span>
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235     p = txStatus-&gt;<a class="code" href="structusbTxStatus.html#ac0cd1cbb98d720cd1f6b458e5dca8b74">buffer</a> + 1;
<a name="l00236"></a>00236     i = len;
<a name="l00237"></a>00237     <span class="keywordflow">do</span>{                         <span class="comment">/* if len == 0, we still copy 1 byte, but that&#39;s no problem */</span>
<a name="l00238"></a>00238         *p++ = *data++;
<a name="l00239"></a>00239     }<span class="keywordflow">while</span>(--i &gt; 0);            <span class="comment">/* loop control at the end is 2 bytes shorter than at beginning */</span>
<a name="l00240"></a>00240     <a class="code" href="usbdrv_8h.html#a19659c3a47ead1ffaa62d50237390f12">usbCrc16Append</a>(&amp;txStatus-&gt;<a class="code" href="structusbTxStatus.html#ac0cd1cbb98d720cd1f6b458e5dca8b74">buffer</a>[1], len);
<a name="l00241"></a>00241     txStatus-&gt;<a class="code" href="structusbTxStatus.html#a3ee6d00644cd8bb758bffffed53022b6">len</a> = len + 4;    <span class="comment">/* len must be given including sync byte */</span>
<a name="l00242"></a>00242     <a class="code" href="oddebug_8h.html#a6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x21 + (((<span class="keywordtype">int</span>)txStatus &gt;&gt; 3) &amp; 3), txStatus-&gt;<a class="code" href="structusbTxStatus.html#ac0cd1cbb98d720cd1f6b458e5dca8b74">buffer</a>, len + 3);
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a><a class="code" href="usbdrv_8h.html#aafa474a799eed02d362bfdfb8a36602c">00245</a> <a class="code" href="usbdrv_8h.html#a5f6aa87267678dc37dd5d97a7b3df7c3">USB_PUBLIC</a> <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#aafa474a799eed02d362bfdfb8a36602c">usbSetInterrupt</a>(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247     usbGenericSetInterrupt(data, len, &amp;usbTxStatus1);
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 <span class="preprocessor">#endif</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>
<a name="l00251"></a>00251 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span><a class="code" href="usbdrv_8h.html#a5f6aa87267678dc37dd5d97a7b3df7c3">USB_PUBLIC</a> <span class="keywordtype">void</span> usbSetInterrupt3(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254     usbGenericSetInterrupt(data, len, &amp;usbTxStatus3);
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 <span class="preprocessor">#endif</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* USB_CFG_SUPPRESS_INTR_CODE */</span>
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment">/* ------------------ utilities for code following below ------------------- */</span>
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="comment">/* Use defines for the switch statement so that we can choose between an</span>
<a name="l00262"></a>00262 <span class="comment"> * if()else if() and a switch/case based implementation. switch() is more</span>
<a name="l00263"></a>00263 <span class="comment"> * efficient for a LARGE set of sequential choices, if() is better in all other</span>
<a name="l00264"></a>00264 <span class="comment"> * cases.</span>
<a name="l00265"></a>00265 <span class="comment"> */</span>
<a name="l00266"></a>00266 <span class="preprocessor">#if USB_CFG_USE_SWITCH_STATEMENT</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_START(cmd)       switch(cmd){{</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE(value)      }break; case (value):{</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_DEFAULT          }break; default:{</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_END              }}</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00274"></a><a class="code" href="usbdrv_8c.html#ac56b9d981e3fec2bbfb3f15788f6bdb2">00274</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){</span>
<a name="l00275"></a><a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">00275</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE(value)      }else if(_cmd == (value)){</span>
<a name="l00276"></a><a class="code" href="usbdrv_8c.html#aae356661dff6a8095d01d3e75dc3d733">00276</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){</span>
<a name="l00277"></a><a class="code" href="usbdrv_8c.html#a4b5329c382b93afc16758e5d08589574">00277</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){</span>
<a name="l00278"></a><a class="code" href="usbdrv_8c.html#a35f0e4ce76d1d63aeebacb74425798b8">00278</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_DEFAULT          }else{</span>
<a name="l00279"></a><a class="code" href="usbdrv_8c.html#a886e28203c262455d99122704a9f0be9">00279</a> <span class="preprocessor"></span><span class="preprocessor">#   define SWITCH_END              }}</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>
<a name="l00282"></a>00282 <span class="preprocessor">#ifndef USB_RX_USER_HOOK</span>
<a name="l00283"></a><a class="code" href="usbdrv_8c.html#a95ad02eb72be3e769e4acf0e98ae40bb">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_RX_USER_HOOK(data, len)</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#ifndef USB_SET_ADDRESS_HOOK</span>
<a name="l00286"></a><a class="code" href="usbdrv_8c.html#a6a78a51b114a555f4fcc13e78af243b0">00286</a> <span class="preprocessor"></span><span class="preprocessor">#define USB_SET_ADDRESS_HOOK()</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>
<a name="l00289"></a>00289 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="comment">/* We use if() instead of #if in the macro below because #if can&#39;t be used</span>
<a name="l00292"></a>00292 <span class="comment"> * in macros and the compiler optimizes constant conditions anyway.</span>
<a name="l00293"></a>00293 <span class="comment"> * This may cause problems with undefined symbols if compiled without</span>
<a name="l00294"></a>00294 <span class="comment"> * optimizing!</span>
<a name="l00295"></a>00295 <span class="comment"> */</span>
<a name="l00296"></a><a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">00296</a> <span class="preprocessor">#define GET_DESCRIPTOR(cfgProp, staticName)         \</span>
<a name="l00297"></a>00297 <span class="preprocessor">    if(cfgProp){                                    \</span>
<a name="l00298"></a>00298 <span class="preprocessor">        if((cfgProp) &amp; USB_PROP_IS_RAM)             \</span>
<a name="l00299"></a>00299 <span class="preprocessor">            flags = 0;                              \</span>
<a name="l00300"></a>00300 <span class="preprocessor">        if((cfgProp) &amp; USB_PROP_IS_DYNAMIC){        \</span>
<a name="l00301"></a>00301 <span class="preprocessor">            len = usbFunctionDescriptor(rq);        \</span>
<a name="l00302"></a>00302 <span class="preprocessor">        }else{                                      \</span>
<a name="l00303"></a>00303 <span class="preprocessor">            len = USB_PROP_LENGTH(cfgProp);         \</span>
<a name="l00304"></a>00304 <span class="preprocessor">            usbMsgPtr = (uchar *)(staticName);      \</span>
<a name="l00305"></a>00305 <span class="preprocessor">        }                                           \</span>
<a name="l00306"></a>00306 <span class="preprocessor">    }</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308 <span class="comment">/* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used</span>
<a name="l00309"></a>00309 <span class="comment"> * internally for all types of descriptors.</span>
<a name="l00310"></a>00310 <span class="comment"> */</span>
<a name="l00311"></a>00311 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a> usbDriverDescriptor(<a class="code" href="structusbRequest.html">usbRequest_t</a> *rq)
<a name="l00312"></a>00312 {
<a name="l00313"></a>00313 <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a> len = 0;
<a name="l00314"></a>00314 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       flags = <a class="code" href="usbdrv_8c.html#a06db19dbad17d54fc6f3742ab0afba69">USB_FLG_MSGPTR_IS_ROM</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <a class="code" href="usbdrv_8c.html#ac56b9d981e3fec2bbfb3f15788f6bdb2">SWITCH_START</a>(rq-&gt;<a class="code" href="structusbRequest.html#ab3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[1])
<a name="l00317"></a>00317     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a5b76593f7b6295a4a599aba4476ec258">USBDESCR_DEVICE</a>)    <span class="comment">/* 1 */</span>
<a name="l00318"></a>00318         <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#aa916bf33f6f8f481a219d0a81b5b225e">USB_CFG_DESCR_PROPS_DEVICE</a>, <a class="code" href="usbdrv_8c.html#a4832dd2433bcc12b444a31dc4a8bfc49">usbDescriptorDevice</a>)
<a name="l00319"></a>00319     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a6ff1081ad7212a0c7009ef5b79f3669f">USBDESCR_CONFIG</a>)    <span class="comment">/* 2 */</span>
<a name="l00320"></a>00320         <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#a8aae9f682ca9f91faae0453e4351a50b">USB_CFG_DESCR_PROPS_CONFIGURATION</a>, <a class="code" href="usbdrv_8c.html#a86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a>)
<a name="l00321"></a>00321     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#aabd48b46ba597bd32ce5c64a7aad23c4">USBDESCR_STRING</a>)    <span class="comment">/* 3 */</span>
<a name="l00322"></a>00322 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#a750fb6cc3e8eafaddae659af97f6f737">USB_CFG_DESCR_PROPS_STRINGS</a> &amp; <a class="code" href="usbdrv_8h.html#a316a7fbfdf2ffb5155980cb14f93d53d">USB_PROP_IS_RAM</a>)
<a name="l00324"></a>00324             flags = 0;
<a name="l00325"></a>00325         len = <a class="code" href="usbdrv_8h.html#a36e4115eff7bf97a7132f6308f923b2b">usbFunctionDescriptor</a>(rq);
<a name="l00326"></a>00326 <span class="preprocessor">#else   </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC */</span>
<a name="l00327"></a>00327         <a class="code" href="usbdrv_8c.html#ac56b9d981e3fec2bbfb3f15788f6bdb2">SWITCH_START</a>(rq-&gt;<a class="code" href="structusbRequest.html#ab3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0])
<a name="l00328"></a>00328         <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(0)
<a name="l00329"></a>00329             <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#a9c0556a4c6c5a1ab8f6598aee8e5bf6a">USB_CFG_DESCR_PROPS_STRING_0</a>, <a class="code" href="usbdrv_8c.html#ac16de84418d64a0e74a4e551fc9ac786">usbDescriptorString0</a>)
<a name="l00330"></a>00330         <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(1)
<a name="l00331"></a>00331             <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#a55edf2117128387162339d98ba2af0f4">USB_CFG_DESCR_PROPS_STRING_VENDOR</a>, <a class="code" href="usbdrv_8c.html#a9974e0350b3ad7adafc3b1f0a47278ca">usbDescriptorStringVendor</a>)
<a name="l00332"></a>00332         <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(2)
<a name="l00333"></a>00333             <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#aa08084f9755a643e02d469b66b129ef6">USB_CFG_DESCR_PROPS_STRING_PRODUCT</a>, <a class="code" href="usbdrv_8c.html#a030c4d21be999d0deafccc65499a44df">usbDescriptorStringDevice</a>)
<a name="l00334"></a>00334         <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(3)
<a name="l00335"></a>00335             <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#a82224c07d3a1f9fcccbff70b71c8ea51">USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER</a>, <a class="code" href="usbdrv_8h.html#a04e6662c39d818a0c4ae16db46276194">usbDescriptorStringSerialNumber</a>)
<a name="l00336"></a>00336         <a class="code" href="usbdrv_8c.html#a35f0e4ce76d1d63aeebacb74425798b8">SWITCH_DEFAULT</a>
<a name="l00337"></a>00337             <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#a3c9ed2d932cf0f5fc9788a91028a8b4b">USB_CFG_DESCR_PROPS_UNKNOWN</a> &amp; <a class="code" href="usbdrv_8h.html#a25fffb901b71f003f9d90c411f998b36">USB_PROP_IS_DYNAMIC</a>){
<a name="l00338"></a>00338                 len = <a class="code" href="usbdrv_8h.html#a36e4115eff7bf97a7132f6308f923b2b">usbFunctionDescriptor</a>(rq);
<a name="l00339"></a>00339             }
<a name="l00340"></a>00340         <a class="code" href="usbdrv_8c.html#a886e28203c262455d99122704a9f0be9">SWITCH_END</a>
<a name="l00341"></a>00341 <span class="preprocessor">#endif  </span><span class="comment">/* USB_CFG_DESCR_PROPS_STRINGS &amp; USB_PROP_IS_DYNAMIC */</span>
<a name="l00342"></a>00342 <span class="preprocessor">#if USB_CFG_DESCR_PROPS_HID_REPORT  </span><span class="comment">/* only support HID descriptors if enabled */</span>
<a name="l00343"></a>00343     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#ade4fe1fba6aca94a379fdbacbbcc6800">USBDESCR_HID</a>)       <span class="comment">/* 0x21 */</span>
<a name="l00344"></a>00344         <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbdrv_8c.html#adfbd53b5310c36b1e4b06d6a3b992e8a">USB_CFG_DESCR_PROPS_HID</a>, <a class="code" href="usbdrv_8c.html#a86288669b638000acf9548272f73e7f6">usbDescriptorConfiguration</a> + 18)
<a name="l00345"></a>00345     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#af2ef6d7e2fe214a3d3a14f5419550bb0">USBDESCR_HID_REPORT</a>)<span class="comment">/* 0x22 */</span>
<a name="l00346"></a>00346         <a class="code" href="usbdrv_8c.html#a4f20ce9fae0dc2160ae0e8c3d8934f15">GET_DESCRIPTOR</a>(<a class="code" href="usbconfig_8h.html#a248eae427d6cea0046661eb8438b7198">USB_CFG_DESCR_PROPS_HID_REPORT</a>, <a class="code" href="usbdrv_8h.html#a5f6ed8eed333942ed365ab158f2f1871">usbDescriptorHidReport</a>)
<a name="l00347"></a>00347 <span class="preprocessor">#endif</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8c.html#a35f0e4ce76d1d63aeebacb74425798b8">SWITCH_DEFAULT</a>
<a name="l00349"></a>00349         <span class="keywordflow">if</span>(<a class="code" href="usbconfig_8h.html#a3c9ed2d932cf0f5fc9788a91028a8b4b">USB_CFG_DESCR_PROPS_UNKNOWN</a> &amp; USB_PROP_IS_DYNAMIC){
<a name="l00350"></a>00350             len = <a class="code" href="usbdrv_8h.html#a36e4115eff7bf97a7132f6308f923b2b">usbFunctionDescriptor</a>(rq);
<a name="l00351"></a>00351         }
<a name="l00352"></a>00352     <a class="code" href="usbdrv_8c.html#a886e28203c262455d99122704a9f0be9">SWITCH_END</a>
<a name="l00353"></a>00353     usbMsgFlags = flags;
<a name="l00354"></a>00354     <span class="keywordflow">return</span> len;
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="comment">/* usbDriverSetup() is similar to usbFunctionSetup(), but it&#39;s used for</span>
<a name="l00360"></a>00360 <span class="comment"> * standard requests instead of class and custom requests.</span>
<a name="l00361"></a>00361 <span class="comment"> */</span>
<a name="l00362"></a>00362 <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a> usbDriverSetup(<a class="code" href="structusbRequest.html">usbRequest_t</a> *rq)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>   len  = 0, *dataPtr = <a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 9;  <span class="comment">/* there are 2 bytes free space at the end of the buffer */</span>
<a name="l00365"></a>00365 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>   value = rq-&gt;<a class="code" href="structusbRequest.html#ab3f8687bb757c53ed03c3ce4310dc5c5">wValue</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00366"></a>00366 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span><a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>   index = rq-&gt;<a class="code" href="structusbRequest.html#aefa059246bf079d5b42af148a2ad6a95">wIndex</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00368"></a>00368 <span class="preprocessor">#endif</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>
<a name="l00370"></a>00370     dataPtr[0] = 0; <span class="comment">/* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */</span>
<a name="l00371"></a>00371     <a class="code" href="usbdrv_8c.html#ac56b9d981e3fec2bbfb3f15788f6bdb2">SWITCH_START</a>(rq-&gt;<a class="code" href="structusbRequest.html#a34c18b1dd0af60774cac48b176220c2c">bRequest</a>)
<a name="l00372"></a>00372     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a523252bd739d1b14018ec34e49466d72">USBRQ_GET_STATUS</a>)           <span class="comment">/* 0 */</span>
<a name="l00373"></a>00373         <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> recipient = rq-&gt;bmRequestType &amp; <a class="code" href="usbdrv_8h.html#a5ae0c6cdfa26c87300c3a01aa2b0c7e2">USBRQ_RCPT_MASK</a>;  <span class="comment">/* assign arith ops to variables to enforce byte size */</span>
<a name="l00374"></a>00374         if(<a class="code" href="usbconfig_8h.html#ad5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a> &amp;&amp; recipient == <a class="code" href="usbdrv_8h.html#aeb145a6378e20ee3aedaa81fffd08d5d">USBRQ_RCPT_DEVICE</a>)
<a name="l00375"></a>00375             dataPtr[0] =  <a class="code" href="usbconfig_8h.html#ad5fd70b5fabd8abd34d5b9ef7100b709">USB_CFG_IS_SELF_POWERED</a>;
<a name="l00376"></a>00376 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(recipient == <a class="code" href="usbdrv_8h.html#a6c25d62097af881d30af436c07773a26">USBRQ_RCPT_ENDPOINT</a> &amp;&amp; index == 0x81)   <span class="comment">/* request status for endpoint 1 */</span>
<a name="l00378"></a>00378             dataPtr[0] = <a class="code" href="usbdrv_8h.html#aac21ed24e5889d02bdecaefb2881dca9">usbTxLen1</a> == <a class="code" href="usbdrv_8h.html#a1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00379"></a>00379 <span class="preprocessor">#endif</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span>        dataPtr[1] = 0;
<a name="l00381"></a>00381         len = 2;
<a name="l00382"></a>00382 <span class="preprocessor">#if USB_CFG_IMPLEMENT_HALT</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8c.html#aae356661dff6a8095d01d3e75dc3d733">SWITCH_CASE2</a>(<a class="code" href="usbdrv_8h.html#a82766d6fb4294e1cb5f7cb2086e81715">USBRQ_CLEAR_FEATURE</a>, <a class="code" href="usbdrv_8h.html#a1802461b0f91708022a66f407fadd1f1">USBRQ_SET_FEATURE</a>)    <span class="comment">/* 1, 3 */</span>
<a name="l00384"></a>00384         if(value == 0 &amp;&amp; index == 0x81){    <span class="comment">/* feature 0 == HALT for endpoint == 1 */</span>
<a name="l00385"></a>00385             <a class="code" href="usbdrv_8h.html#aac21ed24e5889d02bdecaefb2881dca9">usbTxLen1</a> = rq-&gt;<a class="code" href="structusbRequest.html#a34c18b1dd0af60774cac48b176220c2c">bRequest</a> == <a class="code" href="usbdrv_8h.html#a82766d6fb4294e1cb5f7cb2086e81715">USBRQ_CLEAR_FEATURE</a> ? <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a> : <a class="code" href="usbdrv_8h.html#a1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00386"></a>00386             usbResetDataToggling();
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388 <span class="preprocessor">#endif</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a6837bf1e17c56a25b97db0be68b03519">USBRQ_SET_ADDRESS</a>)          <span class="comment">/* 5 */</span>
<a name="l00390"></a>00390         <a class="code" href="usbdrv_8c.html#ab9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a> = value;
<a name="l00391"></a>00391         <a class="code" href="usbdrv_8c.html#a6a78a51b114a555f4fcc13e78af243b0">USB_SET_ADDRESS_HOOK</a>();
<a name="l00392"></a>00392     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a225b041572762941a96694d5498e853e">USBRQ_GET_DESCRIPTOR</a>)       <span class="comment">/* 6 */</span>
<a name="l00393"></a>00393         len = usbDriverDescriptor(rq);
<a name="l00394"></a>00394         goto skipMsgPtrAssignment;
<a name="l00395"></a>00395     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a16d2228bcfa8944c18a39df43016cea5">USBRQ_GET_CONFIGURATION</a>)    <span class="comment">/* 8 */</span>
<a name="l00396"></a>00396         dataPtr = &amp;<a class="code" href="usbdrv_8c.html#aa43502fd98afab29fcd5115c1f2c4067">usbConfiguration</a>;  <span class="comment">/* send current configuration value */</span>
<a name="l00397"></a>00397         len = 1;
<a name="l00398"></a>00398     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#afc6adbbfd47da950ccf50277a41bfe58">USBRQ_SET_CONFIGURATION</a>)    <span class="comment">/* 9 */</span>
<a name="l00399"></a>00399         usbConfiguration = value;
<a name="l00400"></a>00400         usbResetStall();
<a name="l00401"></a>00401     <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a44a94b5f45d9ffb957b9590eea8a73a4">USBRQ_GET_INTERFACE</a>)        <span class="comment">/* 10 */</span>
<a name="l00402"></a>00402         len = 1;
<a name="l00403"></a>00403 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; !USB_CFG_SUPPRESS_INTR_CODE</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8c.html#aae1cadf9c1da7851d3bf26f6044c5963">SWITCH_CASE</a>(<a class="code" href="usbdrv_8h.html#a904cc1bbdd859501d590ce47099a49ec">USBRQ_SET_INTERFACE</a>)        <span class="comment">/* 11 */</span>
<a name="l00405"></a>00405         usbResetDataToggling();
<a name="l00406"></a>00406         usbResetStall();
<a name="l00407"></a>00407 <span class="preprocessor">#endif</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8c.html#a35f0e4ce76d1d63aeebacb74425798b8">SWITCH_DEFAULT</a>                          <span class="comment">/* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */</span>
<a name="l00409"></a>00409         <span class="comment">/* Should we add an optional hook here? */</span>
<a name="l00410"></a>00410     <a class="code" href="usbdrv_8c.html#a886e28203c262455d99122704a9f0be9">SWITCH_END</a>
<a name="l00411"></a>00411     <a class="code" href="usbdrv_8c.html#a5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a> = dataPtr;
<a name="l00412"></a>00412 skipMsgPtrAssignment:
<a name="l00413"></a>00413     <span class="keywordflow">return</span> len;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 <span class="comment">/* usbProcessRx() is called for every message received by the interrupt</span>
<a name="l00419"></a>00419 <span class="comment"> * routine. It distinguishes between SETUP and DATA packets and processes</span>
<a name="l00420"></a>00420 <span class="comment"> * them accordingly.</span>
<a name="l00421"></a>00421 <span class="comment"> */</span>
<a name="l00422"></a>00422 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> usbProcessRx(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424 <a class="code" href="structusbRequest.html">usbRequest_t</a>    *rq = (<span class="keywordtype">void</span> *)data;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">/* usbRxToken can be:</span>
<a name="l00427"></a>00427 <span class="comment"> * 0x2d 00101101 (USBPID_SETUP for setup data)</span>
<a name="l00428"></a>00428 <span class="comment"> * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)</span>
<a name="l00429"></a>00429 <span class="comment"> * 0...0x0f for OUT on endpoint X</span>
<a name="l00430"></a>00430 <span class="comment"> */</span>
<a name="l00431"></a>00431     <a class="code" href="oddebug_8h.html#a6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x10 + (<a class="code" href="usbdrv_8c.html#ae2a9422baba7da8914129e0784ab2c05">usbRxToken</a> &amp; 0xf), data, len + 2); <span class="comment">/* SETUP=1d, SETUP-DATA=11, OUTx=1x */</span>
<a name="l00432"></a>00432     <a class="code" href="usbdrv_8c.html#a95ad02eb72be3e769e4acf0e98ae40bb">USB_RX_USER_HOOK</a>(data, len)
<a name="l00433"></a>00433 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITEOUT</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#ae2a9422baba7da8914129e0784ab2c05">usbRxToken</a> &lt; 0x10){  <span class="comment">/* OUT to endpoint != 0: endpoint number in usbRxToken */</span>
<a name="l00435"></a>00435         usbFunctionWriteOut(data, len);
<a name="l00436"></a>00436         <span class="keywordflow">return</span>;
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438 <span class="preprocessor">#endif</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#ae2a9422baba7da8914129e0784ab2c05">usbRxToken</a> == (<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>)<a class="code" href="usbdrv_8h.html#a3e2083acfa1300227dce323ca04db880">USBPID_SETUP</a>){
<a name="l00440"></a>00440         <span class="keywordflow">if</span>(len != 8)    <span class="comment">/* Setup size must be always 8 bytes. Ignore otherwise. */</span>
<a name="l00441"></a>00441             <span class="keywordflow">return</span>;
<a name="l00442"></a>00442         <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a> replyLen;
<a name="l00443"></a>00443         <a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[0] = <a class="code" href="usbdrv_8h.html#addf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a>;         <span class="comment">/* initialize data toggling */</span>
<a name="l00444"></a>00444         <a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;              <span class="comment">/* abort pending transmit */</span>
<a name="l00445"></a>00445         usbMsgFlags = 0;
<a name="l00446"></a>00446         <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> type = rq-&gt;<a class="code" href="structusbRequest.html#a05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="usbdrv_8h.html#aef7b9c4cc4266e79c677fd42e2abb40e">USBRQ_TYPE_MASK</a>;
<a name="l00447"></a>00447         <span class="keywordflow">if</span>(type != <a class="code" href="usbdrv_8h.html#aa2eaf9447ddfc30442e8b6bd13cfd969">USBRQ_TYPE_STANDARD</a>){    <span class="comment">/* standard requests are handled by driver */</span>
<a name="l00448"></a>00448             replyLen = <a class="code" href="usbdrv_8h.html#a990d35fe479b1ee8abd7c169626b51f6">usbFunctionSetup</a>(data);
<a name="l00449"></a>00449         }<span class="keywordflow">else</span>{
<a name="l00450"></a>00450             replyLen = usbDriverSetup(rq);
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(replyLen == <a class="code" href="usbdrv_8h.html#a0bf378ff9540265128eef4f085176dcc">USB_NO_MSG</a>){         <span class="comment">/* use user-supplied read/write function */</span>
<a name="l00454"></a>00454             <span class="comment">/* do some conditioning on replyLen, but on IN transfers only */</span>
<a name="l00455"></a>00455             <span class="keywordflow">if</span>((rq-&gt;<a class="code" href="structusbRequest.html#a05c2e0d9ac30dce558bcd69a692314c0">bmRequestType</a> &amp; <a class="code" href="usbdrv_8h.html#a7754f61bfa2e16800aa396896092f50a">USBRQ_DIR_MASK</a>) != <a class="code" href="usbdrv_8h.html#aa187b3efe1a0ef577e6f695a47608bef">USBRQ_DIR_HOST_TO_DEVICE</a>){
<a name="l00456"></a>00456                 <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(replyLen) &lt; <span class="keyword">sizeof</span>(rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a5c18356318175be1ad83c8acab90bf66">word</a>)){ <span class="comment">/* help compiler with optimizing */</span>
<a name="l00457"></a>00457                     replyLen = rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00458"></a>00458                 }<span class="keywordflow">else</span>{
<a name="l00459"></a>00459                     replyLen = rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a5c18356318175be1ad83c8acab90bf66">word</a>;
<a name="l00460"></a>00460                 }
<a name="l00461"></a>00461             }
<a name="l00462"></a>00462             usbMsgFlags = <a class="code" href="usbdrv_8c.html#ad2fe7ee90d3349e1399f61eda81d48e9">USB_FLG_USE_USER_RW</a>;
<a name="l00463"></a>00463         }<span class="keywordflow">else</span>   <span class="comment">/* The &#39;else&#39; prevents that we limit a replyLen of USB_NO_MSG to the maximum transfer len. */</span>
<a name="l00464"></a>00464 <span class="preprocessor">#endif</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<span class="keyword">sizeof</span>(replyLen) &lt; <span class="keyword">sizeof</span>(rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a5c18356318175be1ad83c8acab90bf66">word</a>)){ <span class="comment">/* help compiler with optimizing */</span>
<a name="l00466"></a>00466             <span class="keywordflow">if</span>(!rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[1] &amp;&amp; replyLen &gt; rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0])    <span class="comment">/* limit length to max */</span>
<a name="l00467"></a>00467                 replyLen = rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a3efd0ec82e53de09193e9de269434334">bytes</a>[0];
<a name="l00468"></a>00468         }<span class="keywordflow">else</span>{
<a name="l00469"></a>00469             <span class="keywordflow">if</span>(replyLen &gt; rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a5c18356318175be1ad83c8acab90bf66">word</a>)     <span class="comment">/* limit length to max */</span>
<a name="l00470"></a>00470                 replyLen = rq-&gt;<a class="code" href="structusbRequest.html#a770437881c2e37d1384982fe26d87e7f">wLength</a>.<a class="code" href="unionusbWord.html#a5c18356318175be1ad83c8acab90bf66">word</a>;
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472         usbMsgLen = replyLen;
<a name="l00473"></a>00473     }<span class="keywordflow">else</span>{  <span class="comment">/* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */</span>
<a name="l00474"></a>00474 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_WRITE</span>
<a name="l00475"></a>00475 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="usbdrv_8c.html#ad2fe7ee90d3349e1399f61eda81d48e9">USB_FLG_USE_USER_RW</a>){
<a name="l00476"></a>00476             <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> rval = usbFunctionWrite(data, len);
<a name="l00477"></a>00477             <span class="keywordflow">if</span>(rval == 0xff){   <span class="comment">/* an error occurred */</span>
<a name="l00478"></a>00478                 <a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = <a class="code" href="usbdrv_8h.html#a1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;
<a name="l00479"></a>00479             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rval != 0){    <span class="comment">/* This was the final package */</span>
<a name="l00480"></a>00480                 usbMsgLen = 0;  <span class="comment">/* answer with a zero-sized data packet */</span>
<a name="l00481"></a>00481             }
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483 <span class="preprocessor">#endif</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>    }
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">/* This function is similar to usbFunctionRead(), but it&#39;s also called for</span>
<a name="l00490"></a>00490 <span class="comment"> * data handled automatically by the driver (e.g. descriptor reads).</span>
<a name="l00491"></a>00491 <span class="comment"> */</span>
<a name="l00492"></a>00492 <span class="keyword">static</span> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> usbDeviceRead(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> *data, <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> len)
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494     <span class="keywordflow">if</span>(len &gt; 0){    <span class="comment">/* don&#39;t bother app with 0 sized reads */</span>
<a name="l00495"></a>00495 <span class="preprocessor">#if USB_CFG_IMPLEMENT_FN_READ</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(usbMsgFlags &amp; USB_FLG_USE_USER_RW){
<a name="l00497"></a>00497             len = usbFunctionRead(data, len);
<a name="l00498"></a>00498         }<span class="keywordflow">else</span>
<a name="l00499"></a>00499 <span class="preprocessor">#endif</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span>        {
<a name="l00501"></a>00501             <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> i = len, *r = <a class="code" href="usbdrv_8c.html#a5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a>;
<a name="l00502"></a>00502             <span class="keywordflow">if</span>(usbMsgFlags &amp; <a class="code" href="usbdrv_8c.html#a06db19dbad17d54fc6f3742ab0afba69">USB_FLG_MSGPTR_IS_ROM</a>){    <span class="comment">/* ROM data */</span>
<a name="l00503"></a>00503                 <span class="keywordflow">do</span>{
<a name="l00504"></a>00504                     <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> c = <a class="code" href="usbportability_8h.html#a078882d037ab92d73cc70b97738d552d">USB_READ_FLASH</a>(r);    <span class="comment">/* assign to char size variable to enforce byte ops */</span>
<a name="l00505"></a>00505                     *data++ = c;
<a name="l00506"></a>00506                     r++;
<a name="l00507"></a>00507                 }<span class="keywordflow">while</span>(--i);
<a name="l00508"></a>00508             }<span class="keywordflow">else</span>{  <span class="comment">/* RAM data */</span>
<a name="l00509"></a>00509                 <span class="keywordflow">do</span>{
<a name="l00510"></a>00510                     *data++ = *r++;
<a name="l00511"></a>00511                 }<span class="keywordflow">while</span>(--i);
<a name="l00512"></a>00512             }
<a name="l00513"></a>00513             <a class="code" href="usbdrv_8c.html#a5f78c8584830588b8c0c8f2a27772f8e">usbMsgPtr</a> = r;
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516     <span class="keywordflow">return</span> len;
<a name="l00517"></a>00517 }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="comment">/* usbBuildTxBlock() is called when we have data to transmit and the</span>
<a name="l00522"></a>00522 <span class="comment"> * interrupt routine&#39;s transmit buffer is empty.</span>
<a name="l00523"></a>00523 <span class="comment"> */</span>
<a name="l00524"></a>00524 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> usbBuildTxBlock(<span class="keywordtype">void</span>)
<a name="l00525"></a>00525 {
<a name="l00526"></a>00526 <a class="code" href="usbdrv_8h.html#a57df3bf9fc8ec8cd9b29ba8dfc361059">usbMsgLen_t</a> wantLen;
<a name="l00527"></a>00527 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>       len;
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     wantLen = usbMsgLen;
<a name="l00530"></a>00530     <span class="keywordflow">if</span>(wantLen &gt; 8)
<a name="l00531"></a>00531         wantLen = 8;
<a name="l00532"></a>00532     usbMsgLen -= wantLen;
<a name="l00533"></a>00533     <a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[0] ^= <a class="code" href="usbdrv_8h.html#addf02692d5a80756e8edfa12f1fb50c6">USBPID_DATA0</a> ^ <a class="code" href="usbdrv_8h.html#a62e5930e01b6235dd17be080135f1546">USBPID_DATA1</a>; <span class="comment">/* DATA toggling */</span>
<a name="l00534"></a>00534     len = usbDeviceRead(<a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a> + 1, wantLen);
<a name="l00535"></a>00535     <span class="keywordflow">if</span>(len &lt;= 8){           <span class="comment">/* valid data packet */</span>
<a name="l00536"></a>00536         <a class="code" href="usbdrv_8h.html#a19659c3a47ead1ffaa62d50237390f12">usbCrc16Append</a>(&amp;<a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>[1], len);
<a name="l00537"></a>00537         len += 4;           <span class="comment">/* length including sync byte */</span>
<a name="l00538"></a>00538         <span class="keywordflow">if</span>(len &lt; 12)        <span class="comment">/* a partial package identifies end of message */</span>
<a name="l00539"></a>00539             usbMsgLen = <a class="code" href="usbdrv_8h.html#a0bf378ff9540265128eef4f085176dcc">USB_NO_MSG</a>;
<a name="l00540"></a>00540     }<span class="keywordflow">else</span>{
<a name="l00541"></a>00541         len = <a class="code" href="usbdrv_8h.html#a1a3759da5a10e0fb525fbf619b3bdb53">USBPID_STALL</a>;   <span class="comment">/* stall the endpoint */</span>
<a name="l00542"></a>00542         usbMsgLen = <a class="code" href="usbdrv_8h.html#a0bf378ff9540265128eef4f085176dcc">USB_NO_MSG</a>;
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544     <a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> = len;
<a name="l00545"></a>00545     <a class="code" href="oddebug_8h.html#a6c91367860ab33a44869e241022d5b0f">DBG2</a>(0x20, <a class="code" href="usbdrv_8c.html#a2e8d07fcad8aa462b6a1f51e7968f3cb">usbTxBuf</a>, len-1);
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> usbHandleResetHook(<a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> notResetState)
<a name="l00551"></a>00551 {
<a name="l00552"></a>00552 <span class="preprocessor">#ifdef USB_RESET_HOOK</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>    wasReset;
<a name="l00554"></a>00554 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>           isReset = !notResetState;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keywordflow">if</span>(wasReset != isReset){
<a name="l00557"></a>00557         USB_RESET_HOOK(isReset);
<a name="l00558"></a>00558         wasReset = isReset;
<a name="l00559"></a>00559     }
<a name="l00560"></a>00560 <span class="preprocessor">#endif</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span>}
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="usbdrv_8h.html#a188162c29eb62ffbd2d33763d20e12b4">00565</a> <a class="code" href="usbdrv_8h.html#a5f6aa87267678dc37dd5d97a7b3df7c3">USB_PUBLIC</a> <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#a188162c29eb62ffbd2d33763d20e12b4">usbPoll</a>(<span class="keywordtype">void</span>)
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567 <a class="code" href="usbdrv_8h.html#af2cbb84f982ea77dfbb738af3a027591">schar</a>   len;
<a name="l00568"></a>00568 <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a>   i;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     len = <a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> - 3;
<a name="l00571"></a>00571     <span class="keywordflow">if</span>(len &gt;= 0){
<a name="l00572"></a>00572 <span class="comment">/* We could check CRC16 here -- but ACK has already been sent anyway. If you</span>
<a name="l00573"></a>00573 <span class="comment"> * need data integrity checks with this driver, check the CRC in your app</span>
<a name="l00574"></a>00574 <span class="comment"> * code and report errors back to the host. Since the ACK was already sent,</span>
<a name="l00575"></a>00575 <span class="comment"> * retries must be handled on application level.</span>
<a name="l00576"></a>00576 <span class="comment"> * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);</span>
<a name="l00577"></a>00577 <span class="comment"> */</span>
<a name="l00578"></a>00578         usbProcessRx(<a class="code" href="usbdrv_8c.html#a50d7f851abf281804143e797d0bfbf04">usbRxBuf</a> + <a class="code" href="usbdrv_8h.html#a1c541dbab181ea7bd3da61b892430988">USB_BUFSIZE</a> + 1 - <a class="code" href="usbdrv_8c.html#a6b0f7b83997deee705eb56462e3f1fce">usbInputBufOffset</a>, len);
<a name="l00579"></a>00579 <span class="preprocessor">#if USB_CFG_HAVE_FLOWCONTROL</span>
<a name="l00580"></a>00580 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> &gt; 0)    <span class="comment">/* only mark as available if not inactivated */</span>
<a name="l00581"></a>00581             <a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> = 0;
<a name="l00582"></a>00582 <span class="preprocessor">#else</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span>        <a class="code" href="usbdrv_8c.html#a3d8dd46333d7cf2258067c00428efc47">usbRxLen</a> = 0;       <span class="comment">/* mark rx buffer as available */</span>
<a name="l00584"></a>00584 <span class="preprocessor">#endif</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span>    }
<a name="l00586"></a>00586     <span class="keywordflow">if</span>(<a class="code" href="usbdrv_8c.html#a6d1c6f67a95541d4f45d26dd80e07693">usbTxLen</a> &amp; 0x10){    <span class="comment">/* transmit system idle */</span>
<a name="l00587"></a>00587         <span class="keywordflow">if</span>(usbMsgLen != <a class="code" href="usbdrv_8h.html#a0bf378ff9540265128eef4f085176dcc">USB_NO_MSG</a>){    <span class="comment">/* transmit data pending? */</span>
<a name="l00588"></a>00588             usbBuildTxBlock();
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590     }
<a name="l00591"></a>00591     <span class="keywordflow">for</span>(i = 20; i &gt; 0; i--){
<a name="l00592"></a>00592         <a class="code" href="oddebug_8h.html#aa8ddf20cdd716b652e76e23e5e700893">uchar</a> usbLineStatus = <a class="code" href="usbdrv_8h.html#a85296740a603c928460d39ef9be869a4">USBIN</a> &amp; <a class="code" href="usbdrv_8h.html#a0140266b6db5af6ba9167f04a91ca076">USBMASK</a>;
<a name="l00593"></a>00593         <span class="keywordflow">if</span>(usbLineStatus != 0)  <span class="comment">/* SE0 has ended */</span>
<a name="l00594"></a>00594             <span class="keywordflow">goto</span> isNotReset;
<a name="l00595"></a>00595     }
<a name="l00596"></a>00596     <span class="comment">/* RESET condition, called multiple times during reset */</span>
<a name="l00597"></a>00597     <a class="code" href="usbdrv_8c.html#ab9c08d1850db1e4d9feea687bc129425">usbNewDeviceAddr</a> = 0;
<a name="l00598"></a>00598     <a class="code" href="usbdrv_8c.html#a3f91a04b325ad5232d270839891e5856">usbDeviceAddr</a> = 0;
<a name="l00599"></a>00599     usbResetStall();
<a name="l00600"></a>00600     <a class="code" href="oddebug_8h.html#a1b3ae5f24b3863d451c3648fa2ff57be">DBG1</a>(0xff, 0, 0);
<a name="l00601"></a>00601 isNotReset:
<a name="l00602"></a>00602     usbHandleResetHook(i);
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 <span class="comment">/* ------------------------------------------------------------------------- */</span>
<a name="l00606"></a>00606 
<a name="l00607"></a><a class="code" href="usbdrv_8h.html#a5672a0c07f0f8e93bde4579d278e6307">00607</a> <a class="code" href="usbdrv_8h.html#a5f6aa87267678dc37dd5d97a7b3df7c3">USB_PUBLIC</a> <span class="keywordtype">void</span> <a class="code" href="usbdrv_8c.html#a5672a0c07f0f8e93bde4579d278e6307">usbInit</a>(<span class="keywordtype">void</span>)
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609 <span class="preprocessor">#if USB_INTR_CFG_SET != 0</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#a34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> |= <a class="code" href="usbdrv_8h.html#aab47b4721030fcf7b773ab33f8e0f1c9">USB_INTR_CFG_SET</a>;
<a name="l00611"></a>00611 <span class="preprocessor">#endif</span>
<a name="l00612"></a>00612 <span class="preprocessor"></span><span class="preprocessor">#if USB_INTR_CFG_CLR != 0</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#a34cb3bb685c3a6f9c8a63f3a948799b6">USB_INTR_CFG</a> &amp;= ~(<a class="code" href="usbdrv_8h.html#aaaa3f824f11c2a5e75acb3841063120d">USB_INTR_CFG_CLR</a>);
<a name="l00614"></a>00614 <span class="preprocessor">#endif</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#a0259fea2ff25be5c0cd58cce07526f84">USB_INTR_ENABLE</a> |= (1 &lt;&lt; <a class="code" href="usbdrv_8h.html#a3d028bbfd2e3e723bba54a4ac8fd584c">USB_INTR_ENABLE_BIT</a>);
<a name="l00616"></a>00616     usbResetDataToggling();
<a name="l00617"></a>00617 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT &amp;&amp; !USB_CFG_SUPPRESS_INTR_CODE</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#aac21ed24e5889d02bdecaefb2881dca9">usbTxLen1</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00619"></a>00619 <span class="preprocessor">#if USB_CFG_HAVE_INTRIN_ENDPOINT3</span>
<a name="l00620"></a>00620 <span class="preprocessor"></span>    <a class="code" href="usbdrv_8h.html#aca93482629ab3ddcbceedd43f1dd976c">usbTxLen3</a> = <a class="code" href="usbdrv_8h.html#a481d1276a9efab04a3ab871b87771aac">USBPID_NAK</a>;
<a name="l00621"></a>00621 <span class="preprocessor">#endif</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span>}
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="comment">/* ------------------------------------------------------------------------- */</span>
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Mar 4 2012 21:24:35 for softusbduino by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
